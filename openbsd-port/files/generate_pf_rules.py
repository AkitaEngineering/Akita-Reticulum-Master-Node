#!/usr/local/bin/python3
# $OpenBSD$
#
# Helper script for Akita Reticulum rc.d service to generate PF anchor rules
# based on the Reticulum configuration file.

import sys
import yaml
import ipaddress
import os
import socket # For hostname resolution

# Default Reticulum port (used by AutoInterface, UDPInterface if not specified)
DEFAULT_RNS_UDP_PORT = 4242
# Default base directory for finding interfaces if not absolute
DEFAULT_IF_BASE = "/sys/class/net/" # Linux specific, might not be relevant for OpenBSD pf rules directly

def is_valid_port(port_val):
    """ Check if a value is a valid TCP/UDP port """
    try:
        port = int(port_val)
        return 1 <= port <= 65535
    except (ValueError, TypeError):
        return False

def resolve_host(hostname):
    """ Try to resolve hostname to an IP address (returns first IPv4 found) """
    try:
        # Get first IPv4 address
        addr_info = socket.getaddrinfo(hostname, None, socket.AF_INET)
        return addr_info[0][4][0] if addr_info else None
    except socket.gaierror:
        return None # Could not resolve

def generate_rules(config_path):
    """Parses the Reticulum config and prints PF rules to stdout."""
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f) # Use safe_load
    except FileNotFoundError:
        print(f"# Error: Config file not found: {config_path}", file=sys.stderr)
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"# Error: Failed to parse YAML config {config_path}: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"# Error: Unexpected error reading config {config_path}: {e}", file=sys.stderr)
        sys.exit(1)

    if not isinstance(config, dict):
        print(f"# Error: Invalid config format in {config_path} - expected a dictionary.", file=sys.stderr)
        sys.exit(1)

    interfaces = config.get('interfaces', [])
    if not isinstance(interfaces, list):
        print(f"# Error: Invalid config format: 'interfaces' is not a list.", file=sys.stderr)
        sys.exit(1)

    print(f"# Auto-generated PF rules based on {config_path}")
    print(f"# Generated by: {os.path.basename(__file__)}")
    print("# ---")

    rules_generated = False
    for iface_config in interfaces:
        if not isinstance(iface_config, dict):
            print(f"# Warning: Skipping invalid interface entry (not a dict): {iface_config}", file=sys.stderr)
            continue

        # Check top-level 'enabled' flag for the interface block
        if not iface_config.get('enabled', True):
             # Skip disabled interfaces silently unless verbose debugging is added
             continue

        # Check interface-specific 'pf_managed' flag (defaults to True if not present)
        if not iface_config.get('pf_managed', True):
            print(f"# Info: Skipping PF rule generation for interface (pf_managed: false): {iface_config.get('name', 'unnamed')}")
            continue

        iface_type = iface_config.get('type')
        iface_name = iface_config.get('name', 'unnamed')
        iface_dev = iface_config.get('device') # Used by UDP, TUN

        try:
            # --- AutoInterface / UDPInterface ---
            if iface_type == 'AutoInterface' or iface_type == 'UDPInterface':
                udp_port = iface_config.get('port', DEFAULT_RNS_UDP_PORT)
                if not is_valid_port(udp_port):
                    print(f"# Warning: Skipping {iface_type} ({iface_name}) - invalid port: {udp_port}", file=sys.stderr)
                    continue

                target_host = iface_config.get('target_host')
                target_port = iface_config.get('target_port', udp_port)
                group = iface_config.get('group')

                # Basic rule allows broadcast/multicast/unicast listen on the port
                # Specifying 'on device' might be too restrictive if device isn't always known/used by pf
                # Let pf match based on destination IP/port primarily.
                # if_spec = f"on {iface_dev} " if iface_dev else "" # Consider if this adds value or complexity
                if_spec = ""
                rule_comment = f"# {iface_type} ({iface_name}) port {udp_port}"
                if target_host:
                     rule_comment += f" -> {target_host}:{target_port}"
                if group:
                     rule_comment += f" group {group}"

                # Allow incoming packets to the listen port
                print(f"pass in quick {if_spec}proto udp from any to any port {udp_port} {rule_comment}")
                # Allow outgoing packets originating from the listen port (replies/broadcasts)
                # Using 'keep state' might be better for replies if pf is stateful.
                print(f"pass out quick {if_spec}proto udp from any port {udp_port} to any {rule_comment}")
                rules_generated = True

            # --- TCPInterface ---
            elif iface_type == 'TCPInterface':
                listen_port = iface_config.get('listen_port')
                target_host = iface_config.get('target_host')
                target_port = iface_config.get('target_port')

                if listen_port:
                    if not is_valid_port(listen_port):
                        print(f"# Warning: Skipping {iface_type} ({iface_name}) - invalid listen_port: {listen_port}", file=sys.stderr)
                        continue
                    # Rule for listening TCP socket
                    bind_ip = iface_config.get('bind_ip', 'any') # Default listen on all IPs
                    to_spec = f"to {bind_ip}" if bind_ip != 'any' else "to any"
                    print(f"pass in quick proto tcp from any {to_spec} port {listen_port} keep state # {iface_type} listen ({iface_name}) port {listen_port}")
                    # Outgoing replies handled by stateful rule above
                    rules_generated = True
                elif target_host and is_valid_port(target_port):
                    # Outgoing connections don't need specific 'pass in' rules usually.
                    # An outgoing rule might be needed if default policy is block.
                    print(f"# Info: Outgoing-only TCPInterface ({iface_name} to {target_host}:{target_port}) typically doesn't require generated PF rules unless default policy blocks outgoing.")
                else:
                    print(f"# Warning: Skipping {iface_type} ({iface_name}) - invalid/incomplete configuration.", file=sys.stderr)


            # --- TUNInterface ---
            elif iface_type == 'TUNInterface':
                if iface_dev:
                    # Basic rule: allow all traffic IN and OUT on the TUN interface.
                    # Assumes filtering happens elsewhere or isn't needed here.
                    print(f"pass quick on {iface_dev} # {iface_type} ({iface_name}) device {iface_dev}")
                    rules_generated = True
                else:
                     print(f"# Warning: Skipping TUNInterface ({iface_name}) - missing 'device'.", file=sys.stderr)

            # Add other interface types like RNodeInterface if they need specific PF handling
            # e.g., RNodeInterface often uses SerialInterface underneath, no pf rules needed directly.

        except Exception as e:
            print(f"# Warning: Error processing interface {iface_name} ({iface_type}): {e}", file=sys.stderr)

    if not rules_generated:
        print("# No specific PF rules generated based on enabled and managed interfaces.")

    print("# ---")
    print("# Note: Review these rules carefully. They are basic allowances and may")
    print("# need adjustment based on your specific network topology and security")
    print("# requirements (e.g., restricting 'from any', using specific interfaces).")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {os.path.basename(__file__)} <path_to_reticulum_config>", file=sys.stderr)
        sys.exit(1)
    generate_rules(sys.argv[1])
